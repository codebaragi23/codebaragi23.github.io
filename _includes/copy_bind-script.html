<!-- <script>
(function(document, history, location) {
  var HISTORY_SUPPORT = !!(history && history.pushState);

  var anchorScrolls = {
    ANCHOR_REGEX: /^#[^ ]+$/,
    OFFSET_HEIGHT_PX: -70,

    /**
     * Establish events, and fix initial scroll position if a hash is provided.
     */
    init: function() {
      this.scrollToCurrent();
      window.addEventListener('hashchange', this.scrollToCurrent.bind(this));
      document.body.addEventListener('click', this.delegateAnchors.bind(this));
    },

    /**
     * Return the offset amount to deduct from the normal scroll position.
     * Modify as appropriate to allow for dynamic calculations
     */
    getFixedOffset: function() {
      return this.OFFSET_HEIGHT_PX;
    },

    /**
     * If the provided href is an anchor which resolves to an element on the
     * page, scroll to it.
     * @param  {String} href
     * @return {Boolean} - Was the href an anchor.
     */
    scrollIfAnchor: function(href, pushToHistory) {
      var match, rect, anchorOffset;

      if(!this.ANCHOR_REGEX.test(href)) {
        return false;
      }

      match = document.getElementById(href.slice(1));

      if(match) {
        rect = match.getBoundingClientRect();
        anchorOffset = window.pageYOffset + rect.top + this.getFixedOffset();
        window.scrollTo(window.pageXOffset, anchorOffset);

        // Add the state to history as-per normal anchor links
        if(HISTORY_SUPPORT && pushToHistory) {
          history.pushState({}, document.title, location.pathname + href);
        }
      }

      return !!match;
    },

    /**
     * Attempt to scroll to the current location's hash.
     */
    scrollToCurrent: function() {
      this.scrollIfAnchor(window.location.hash);
    },

    /**
     * If the click event's target was an anchor, fix the scroll position.
     */
    delegateAnchors: function(e) {
      var elem = e.target;

      if(
        elem.nodeName === 'A' &&
        this.scrollIfAnchor(elem.getAttribute('href'), true)
      ) {
        e.preventDefault();
      }
    }
  };

  window.addEventListener(
    'DOMContentLoaded', anchorScrolls.init.bind(anchorScrolls)
  );
})(window.document, window.history, window.location);
</script> -->

<!-- <script>
  function escapeHTML(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  (function($) {
    $("body").bind('copy', function (e) {
      var url = document.location.href;
      var decodedUrl = decodeURI(url);
      var selection = window.getSelection();
      
      if (typeof window.getSelection == "undefined") {//IE8 or earlier...
        event.preventDefault();

        var pagelink = '\n\n 출처: ' + decodedUrl;
        var copytext = selection + pagelink;

        if (window.clipboardData) {
          window.clipboardData.setData('Text', copytext);
        }
        return;
      }

      var body_element = document.getElementsByTagName('body')[0];

      //if the selection is short let's not annoy our users
      if (("" + selection).length < 30) return;

      //create a div outside of the visible area
      var newdiv = document.createElement('div');
      newdiv.style.position = 'absolute';
      newdiv.style.left = '-99999px';
      body_element.appendChild(newdiv);
      newdiv.appendChild(selection.getRangeAt(0).cloneContents());

      //we need a <pre> tag workaround
      //otherwise the text inside "pre" loses all the line breaks!
      if (selection.getRangeAt(0).commonAncestorContainer.nodeName == "PRE") {
        newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
      }

      newdiv.innerHTML += '<br/><br/>출처: <a href="' + url + '">' + escapeHTML(decodedUrl) + '</a> [' + $('meta[property="og:site_name"]').attr('content') + ']';

      selection.selectAllChildren(newdiv);
      console.log(selection);

      window.setTimeout(function () {
        body_element.removeChild(newdiv);
      }, 200);
    });
  })(jQuery);
</script> -->